\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename check.info
@include version.texi
@settitle Check @value{VERSION}
@syncodeindex fn cp
@syncodeindex tp cp
@c %**end of header

@copying
This manual is for Check
(version @value{VERSION}, @value{UPDATED}),
a unit test framework for C programs.

Copyright @copyright{} 2001--2006 Arien Malec and Chris Pickett

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @acronym{GNU} Free Documentation License,
Version 1.2 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover texts, and no
Back-Cover Texts.  A copy of the license is included in the section
entitled ``@acronym{GNU} Free Documentation License.''
@end quotation
@end copying

@dircategory Software development
@direntry
* Check: (check)Introduction.
@end direntry

@titlepage
@title Check
@subtitle A Unit Test Framework for C
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Arien Malec 
@author Chris Pickett

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top Check

@insertcopying
@end ifnottex

@menu
* Introduction::                
* Unit Testing in C::           
* Tutorial::                    
* Copying This Manual::         
* Index::                       

@detailmenu
 --- The Detailed Node Listing ---

Unit Testing in C 

* Other Frameworks for C::      

Tutorial: Basic Unit Testing

* How to Write a Test::         
* Setting Up the @code{libmoney} Tests::  

Copying This Manual

* GNU Free Documentation License::  License for copying this manual.

@end detailmenu
@end menu

@node Introduction, Unit Testing in C, Top, Top
@chapter Introduction
@cindex introduction

Check is a unit testing framework for C.  It was inspired by similar
frameworks that currently exist for most programming languages; the
most famous example being @uref{http://www.junit.org, JUnit} for Java.
There is a list of unit test frameworks for multiple languages at
@uref{http://www.xprogramming.com/software.htm}.  Unit testing has a
long history as part of formal quality assurance methodologies, but
has recently been associated with the lightweight methodology called
Extreme Programming.  In that methodology, the characteristic practice
involves interspersing unit test writing with coding (``test a
little, code a little'').  While the incremental unit test/code
approach is indispensable to Extreme Programming, it is also
applicable, and perhaps indispensable, outside of that methodology.

The incremental test/code approach provides three main benefits to the
developer:

@enumerate
@item
Because the unit tests use the interface to the unit being tested,
they allow the developer to think about how the interface should be
designed for usage early in the coding process.

@item
They help the developer think early about aberrant cases, and code
accordingly.

@item
By providing a documented level of correctness, they allow the
developer to refactor (see @uref{http://www.refactoring.com})
aggressively.
@end enumerate

That third reason is the one that turns people into unit testing
addicts.  There is nothing so satisfying as doing a wholesale
replacement of an implementation, and having the unit tests reassure
you at each step of that change that all is well.  It is like the
difference between exploring the wilderness with and without a good
map and compass: without the proper gear, you are more likely to
proceed cautiously and stick to the marked trails; with it, you can
take the most direct path to where you want to go.

Look at the Check homepage for the latest information on Check:
@uref{http://check.sourceforge.net}.

The Check project page is at:
@uref{http://sourceforge.net/projects/check/}.

@node Unit Testing in C, Tutorial, Introduction, Top
@chapter Unit Testing in C 
@ C unit testing

The approach to unit testing frameworks used for Check originated with
Smalltalk, which is a late binding object-oriented language supporting
reflection.  Writing a framework for C requires solving some special
problems that frameworks for Smalltalk, Java or Python don't have to
face.  In all of those language, the worst that a unit test can do is
fail miserably, throwing an exception of some sort.  In C, a unit test
is just as likely to trash its address space as it is to fail to meet
its test requirements, and if the test framework sits in the same
address space, goodbye test framework.  

To solve this problem, Check uses the @code{fork()} system call to
create a new address space in which to run each unit test, and then
uses message queues to send information on the testing process back to
the test framework.  That way, your unit test can do all sorts of
nasty things with pointers, and throw a segmentation fault, and the
test framework will happily note a unit test error, and chug along.

The Check framework is also designed to play happily with common
development environments for C programming.  The author designed Check
around Autoconf/Automake (thus the name Check: @command{make check} is
the idiom used for testing with Autoconf/Automake), and the test
failure messages thrown up by Check use the common idiom of
@samp{filename:linenumber:message} used by @command{gcc} and family to
report problems in source code.  With (X)Emacs, the output of Check
allows one to quickly navigate to the location of the unit test that
failed; presumably that also works in VI and IDEs.

@menu
* Other Frameworks for C::      
@end menu

@node Other Frameworks for C,  , Unit Testing in C, Unit Testing in C
@section Other Frameworks for C
@cindex other frameworks
@cindex frameworks

The authors know of the following additional unit testing frameworks
for C:

@table @asis

@item GNU Autounit
Much along the same lines as Check, including forking to run unit
tests in a separate address space (in fact, the original author of
Check borrowed the idea from @acronym{GNU} Autounit).  @acronym{GNU}
Autounit uses GLib extensively, which means that linking and such need
special options, but this may not be a big problem to you, especially
if you are already using GTK or GLib.  See the
@uref{http://www.recursism.com/s2004/zp/products/gnu+autounit, GNU
Autounit homepage}.

@item cUnit
Also uses GLib, but does not fork to protect the address space of unit
tests.  See the
@uref{http://web.archive.org/web/*/http://people.codefactory.se/~spotty/cunit/,
archived cUnit homepage}.

@item CUnit
Standard C, with plans for a Win32 GUI implementation.  Does not
currently fork or otherwise protect the address space of unit tests.
In early development.  See the @uref{http://cunit.sourceforge.net,
CUnit homepage}.

@item CppUnit
The premier unit test framework for C++; you can also use it to test C
code.  It is stable, actively developed, and has a GUI interface.  The
primary reasons not to use CppUnit for C are first that it is quite
big, and second you have to write your tests in C++, which means you
need a C++ compiler.  If these don't sound like concerns, it is
definitely worth considering, along with other C++ unit testing
frameworks.  See the
@uref{http://cppunit.sourceforge.net/cppunit-wikie, CppUnit homepage}.

@item MinUnit
A minimal set of macros and that's it!  The point is to
show how easy it is to unit test your code.  See the
@uref{http://www.jera.com/techinfo/jtns/jtn002.html, MinUnit
homepage}.

@item CUnit for Mr. Ando
A CUnit implementation that is fairly new, and apparently still in
early development.  See the 
@uref{http://park.ruru.ne.jp/ando/work/CUnitForAndo/html/, CUnit for
Mr. Ando homepage}.
@end table

This list was last updated in March 2006.  If you know of other C unit
test frameworks, please send an email plus description to
@email{check-devel@@lists.sourceforge.net} and we will add the entry
to this list.

It is the authors' considered opinion that forking or otherwise
trapping and reporting signals is indispensable for unit testing (but
it probably wouldn't be hard to add that to frameworks without that
feature).  Try 'em all out: adapt this tutorial to use all of the
frameworks above, and use whichever you like.  Contribute, spread the
word, and make one a standard.  Languages such as Java and Python are
fortunate to have standard unit test frameworks; it would be desirable
that C have one as well.

@node Tutorial, Copying This Manual, Unit Testing in C, Top
@chapter Tutorial: Basic Unit Testing

This tutorial will use the JUnit
@uref{http://junit.sourceforge.net/doc/testinfected/testing.htm, Test
Infected} article as a starting point.  We will be creating a library
to represent money, @code{libmoney}, that allows conversions between
different currency types.  The development style will be ``test a
little, code a little'', with unit test writing preceding coding.
This constantly gives us insights into module usage, and also makes
sure we are constantly thinking about how to test our code.

@menu
* How to Write a Test::         
* Setting Up the @code{libmoney} Tests::  
@end menu

@node How to Write a Test, Setting Up the @code{libmoney} Tests, Tutorial, Tutorial
@section How to Write a Test

Test writing using Check is very simple. The file in which the checks
are defined must include @file{check.h} as so:

@verbatim
#include <check.h>
@end verbatim

The basic unit test looks as follows:

@verbatim
START_TEST (test_name)
{
  /* unit test code */
}
END_TEST
@end verbatim

The @code{START_TEST}/@code{END_TEST} pair are macros that setup basic
structures to permit testing.  It is a mistake to leave off the
@code{END_TEST} marker; doing so produces all sorts of strange errors
when the check is compiled.

@node Setting Up the @code{libmoney} Tests,  , How to Write a Test, Tutorial
@section Setting Up the @code{libmoney} Tests

The examples in this section are part of the Check distribution; you
don't need to spend time cutting and pasting or (worse) retyping.
Locate the Check documentation on your system and look in the
@samp{example} directory.  The standard directory for GNU/Linux
distributions is @samp{/usr/share/doc/check/example}.  There is an
initial skeleton, in which our unit tests fail, and a final version in
which all tests pass.
@c FIXME: create initial version of tutorial example

Since we are creating a library to handle money, we will first create
a header @file{money.h}, and a file to contain our unit tests,
@file{check_money.c}.  To manage everything we'll use Autoconf,
Automake, and friends (collectively known as Autotools) for this
example.  One could do something similar with ordinary Makefiles, but
in the authors' opinion, it is generally easier to use Autotools than
bare Makefiles, and they provide built-in support for running tests.  

Note that this is not the place to explain how Autotools works.  If
you need help understanding what's going on beyond the explanations
here, the best place to start is probably Alexandre Duret-Lutz's
excellent
@uref{http://www-src.lip6.fr/homepages/Alexandre.Duret-Lutz/autotools.html,
Autotools tutorial}.

We set up a directory structure as follows:

@verbatim
.
|-- Makefile.am
|-- README
|-- configure.ac
|-- src
|   |-- Makefile.am
|   |-- main.c
|   |-- money.c
|   `-- money.h
`-- tests
    |-- Makefile.am
    `-- check_money.c
@end verbatim

Note that this is the output of @command{tree}, a great directory
visualization tool.

The top-level @file{Makefile.am} is simple; it merely tells Automake
how to process subdirectories:

@verbatim
SUBDIRS = src . tests
@end verbatim

@file{configure.ac} is standard Autoconf boilerplate, as specified by
the Autotools tutorial and as suggested by @command{autoscan}.  The
@code{AM_PATH_CHECK()} line does three things:

@enumerate
@item 
Ensure check.h is available

@item 
Ensure a compatible version of Check is installed

@item 
Set @env{CHECK_CFLAGS} and @env{CHECK_LIBS} for use by Automake.
@end enumerate

@file{src/Makefile.am} builds @samp{libmoney} as a Libtool archive,
and links it to an application simply called @command{main}.  The
application's behaviour is not important to this tutorial; what's
important is that none of the functions we want to unit test appear in
@file{main.c}; this probably means that the only function in
@file{main.c} should be @code{main()} itself.  In order to test the
whole application, unit testing is not appropriate: we should use a
system testing tool like Autotest.

Here is the @file{Makefile.am}:

@verbatim
   </para>
   <programlisting>
TESTS=check_money
noinst_PROGRAMS=check_money
check_money_SOURCES=  money.h money.c check_money.c
check_money_INCLUDES= @CHECK_CFLAGS@
check_money_LDADD= @CHECK_LIBS@</programlisting>
   <para>

 The money.h header should only contain the standard &num;ifndef MONEY_H stuff, money.c should be empty, and check_money.c should only contain an empty main function. Run this with make -k check, after going through the setups to get autoconf and friends working. If all goes well, make should report that our tests passed. No surprise, because there aren't any tests to fail.
   </para>
   <para>
The AM_PATH_CHECK() macro is defined in the file check.m4 which is installed by Check. If you see warnings from automake or aclocal this most certainly means that you forgot to call aclocal or that aclocal can't find check.m4. AM_PATH_CHECK() has some optional parameters that you might find useful:
   </para>
   <programlisting>
AM_PATH_CHECK([MINIMUM-VERSION,[ACTION-IF-FOUND[,ACTION-IF-NOT-FOUND]]])</programlisting>

   <para>
One way to run the autoconf/automake tools is shown below in a simple
shell script. The variable CHECK_DIR should point to the directory
where check.m4 is installed. If you install it in a standard location,
e.g. /usr/share/aclocal, then you won't need the variable defined.
   </para>
   <programlisting>
#!/bin/sh
if [ -n "$CHECK_DIR" ]; then
    aclocal -I $CHECK_DIR
else
    aclocal
fi
autoconf
autoheader
automake --add-missing</programlisting>

This 

This shell script and the above configure.in were run on a Red Hat 9
box with Autoconf version 2.13 and automake (GNU automake) 1.4-p6. As
the saying goes, &quot;Your mileage may vary...&quot;
@end verbatim


@node Copying This Manual, Index, Tutorial, Top
@appendix Copying This Manual

@menu
* GNU Free Documentation License::  License for copying this manual.
@end menu

@include fdl.texi


@node Index,  , Copying This Manual, Top
@unnumbered Index

@printindex cp

@bye
