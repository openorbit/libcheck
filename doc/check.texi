\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename check.info
@include version.texi
@settitle Check @value{VERSION}
@syncodeindex fn cp
@syncodeindex tp cp
@c %**end of header

@copying
This manual is for Check
(version @value{VERSION}, @value{UPDATED}),
a unit test framework for C programs.

Copyright @copyright{} 2001--2006 Fredrik Hugosson, Robert Lemmen,
Arien Malec, and Chris Pickett.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @acronym{GNU} Free Documentation License,
Version 1.2 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover texts, and no
Back-Cover Texts.  A copy of the license is included in the section
entitled ``@acronym{GNU} Free Documentation License.''
@end quotation
@end copying

@dircategory Software development
@direntry
* Check: (check)Introduction.
@end direntry

@titlepage
@title Check
@subtitle A Unit Test Framework for C
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Arien Malec 
@author Chris Pickett

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top Check

@insertcopying
@end ifnottex

@menu
* Introduction::                
* Unit Testing in C::           
* Tutorial::                    
* AM_PATH_CHECK::               
* Copying This Manual::         
* Index::                       

@detailmenu
 --- The Detailed Node Listing ---

Unit Testing in C 

* Other Frameworks for C::      

Tutorial: Basic Unit Testing

* How to Write a Test::         
* Setting Up the Money Build::  
* Test a Little::               
* Creating a Suite::            

Copying This Manual

* GNU Free Documentation License::  License for copying this manual.

@end detailmenu
@end menu

@node Introduction, Unit Testing in C, Top, Top
@chapter Introduction
@cindex introduction

Check is a unit testing framework for C.  It was inspired by similar
frameworks that currently exist for most programming languages; the
most famous example being @uref{http://www.junit.org, JUnit} for Java.
There is a list of unit test frameworks for multiple languages at
@uref{http://www.xprogramming.com/software.htm}.  Unit testing has a
long history as part of formal quality assurance methodologies, but
has recently been associated with the lightweight methodology called
Extreme Programming.  In that methodology, the characteristic practice
involves interspersing unit test writing with coding (``test a
little, code a little'').  While the incremental unit test/code
approach is indispensable to Extreme Programming, it is also
applicable, and perhaps indispensable, outside of that methodology.

The incremental test/code approach provides three main benefits to the
developer:

@enumerate
@item
Because the unit tests use the interface to the unit being tested,
they allow the developer to think about how the interface should be
designed for usage early in the coding process.

@item
They help the developer think early about aberrant cases, and code
accordingly.

@item
By providing a documented level of correctness, they allow the
developer to refactor (see @uref{http://www.refactoring.com})
aggressively.
@end enumerate

That third reason is the one that turns people into unit testing
addicts.  There is nothing so satisfying as doing a wholesale
replacement of an implementation, and having the unit tests reassure
you at each step of that change that all is well.  It is like the
difference between exploring the wilderness with and without a good
map and compass: without the proper gear, you are more likely to
proceed cautiously and stick to the marked trails; with it, you can
take the most direct path to where you want to go.

Look at the Check homepage for the latest information on Check:
@uref{http://check.sourceforge.net}.

The Check project page is at:
@uref{http://sourceforge.net/projects/check/}.

@node Unit Testing in C, Tutorial, Introduction, Top
@chapter Unit Testing in C 
@ C unit testing

The approach to unit testing frameworks used for Check originated with
Smalltalk, which is a late binding object-oriented language supporting
reflection.  Writing a framework for C requires solving some special
problems that frameworks for Smalltalk, Java or Python don't have to
face.  In all of those language, the worst that a unit test can do is
fail miserably, throwing an exception of some sort.  In C, a unit test
is just as likely to trash its address space as it is to fail to meet
its test requirements, and if the test framework sits in the same
address space, goodbye test framework.  

To solve this problem, Check uses the @code{fork()} system call to
create a new address space in which to run each unit test, and then
uses message queues to send information on the testing process back to
the test framework.  That way, your unit test can do all sorts of
nasty things with pointers, and throw a segmentation fault, and the
test framework will happily note a unit test error, and chug along.

The Check framework is also designed to play happily with common
development environments for C programming.  The author designed Check
around Autoconf/Automake (thus the name Check: @command{make check} is
the idiom used for testing with Autoconf/Automake), and the test
failure messages thrown up by Check use the common idiom of
@samp{filename:linenumber:message} used by @command{gcc} and family to
report problems in source code.  With (X)Emacs, the output of Check
allows one to quickly navigate to the location of the unit test that
failed; presumably that also works in VI and IDEs.

@menu
* Other Frameworks for C::      
@end menu

@node Other Frameworks for C,  , Unit Testing in C, Unit Testing in C
@section Other Frameworks for C
@cindex other frameworks
@cindex frameworks

The authors know of the following additional unit testing frameworks
for C:

@table @asis

@item GNU Autounit
Much along the same lines as Check, including forking to run unit
tests in a separate address space (in fact, the original author of
Check borrowed the idea from @acronym{GNU} Autounit).  @acronym{GNU}
Autounit uses GLib extensively, which means that linking and such need
special options, but this may not be a big problem to you, especially
if you are already using GTK or GLib.  See the
@uref{http://www.recursism.com/s2004/zp/products/gnu+autounit, GNU
Autounit homepage}.

@item cUnit
Also uses GLib, but does not fork to protect the address space of unit
tests.  See the
@uref{http://web.archive.org/web/*/http://people.codefactory.se/~spotty/cunit/,
archived cUnit homepage}.

@item CUnit
Standard C, with plans for a Win32 GUI implementation.  Does not
currently fork or otherwise protect the address space of unit tests.
In early development.  See the @uref{http://cunit.sourceforge.net,
CUnit homepage}.

@item CppUnit
The premier unit test framework for C++; you can also use it to test C
code.  It is stable, actively developed, and has a GUI interface.  The
primary reasons not to use CppUnit for C are first that it is quite
big, and second you have to write your tests in C++, which means you
need a C++ compiler.  If these don't sound like concerns, it is
definitely worth considering, along with other C++ unit testing
frameworks.  See the
@uref{http://cppunit.sourceforge.net/cppunit-wikie, CppUnit homepage}.

@item MinUnit
A minimal set of macros and that's it!  The point is to
show how easy it is to unit test your code.  See the
@uref{http://www.jera.com/techinfo/jtns/jtn002.html, MinUnit
homepage}.

@item CUnit for Mr. Ando
A CUnit implementation that is fairly new, and apparently still in
early development.  See the 
@uref{http://park.ruru.ne.jp/ando/work/CUnitForAndo/html/, CUnit for
Mr. Ando homepage}.
@end table

This list was last updated in March 2006.  If you know of other C unit
test frameworks, please send an email plus description to
@email{check-devel@@lists.sourceforge.net} and we will add the entry
to this list.

It is the authors' considered opinion that forking or otherwise
trapping and reporting signals is indispensable for unit testing (but
it probably wouldn't be hard to add that to frameworks without that
feature).  Try 'em all out: adapt this tutorial to use all of the
frameworks above, and use whichever you like.  Contribute, spread the
word, and make one a standard.  Languages such as Java and Python are
fortunate to have standard unit test frameworks; it would be desirable
that C have one as well.

@node Tutorial, AM_PATH_CHECK, Unit Testing in C, Top
@chapter Tutorial: Basic Unit Testing

This tutorial will use the JUnit
@uref{http://junit.sourceforge.net/doc/testinfected/testing.htm, Test
Infected} article as a starting point.  We will be creating a library
to represent money, @code{libmoney}, that allows conversions between
different currency types.  The development style will be ``test a
little, code a little'', with unit test writing preceding coding.
This constantly gives us insights into module usage, and also makes
sure we are constantly thinking about how to test our code.

@menu
* How to Write a Test::         
* Setting Up the Money Build::  
* Test a Little::               
* Creating a Suite::            
@end menu

@node How to Write a Test, Setting Up the Money Build, Tutorial, Tutorial
@section How to Write a Test

Test writing using Check is very simple. The file in which the checks
are defined must include @file{check.h} as so:
@example
@verbatim
#include <check.h>
@end verbatim
@end example

The basic unit test looks as follows:
@example
@verbatim
START_TEST (test_name)
{
  /* unit test code */
}
END_TEST
@end verbatim
@end example

The @code{START_TEST}/@code{END_TEST} pair are macros that setup basic
structures to permit testing.  It is a mistake to leave off the
@code{END_TEST} marker; doing so produces all sorts of strange errors
when the check is compiled.

@node Setting Up the Money Build, Test a Little, How to Write a Test, Tutorial
@section Setting Up the Money Build

Since we are creating a library to handle money, we will first create
an interface in @file{money.h}, an implementation in @file{money.c},
and a place to store our unit tests, @file{check_money.c}.  We want to
integrate these core files into our build system, and will need some
additional structure. To manage everything we'll use Autoconf,
Automake, and friends (collectively known as Autotools) for this
example.  One could do something similar with ordinary Makefiles, but
in the authors' opinion, it is generally easier to use Autotools than
bare Makefiles, and they provide built-in support for running tests.

Note that this is not the place to explain how Autotools works.  If
you need help understanding what's going on beyond the explanations
here, the best place to start is probably Alexandre Duret-Lutz's
excellent
@uref{http://www-src.lip6.fr/homepages/Alexandre.Duret-Lutz/autotools.html,
Autotools tutorial}.

The examples in this section are part of the Check distribution; you
don't need to spend time cutting and pasting or (worse) retyping them.
Locate the Check documentation on your system and look in the
@samp{example} directory.  The standard directory for GNU/Linux
distributions should be @samp{/usr/share/doc/check/example}.  This
directory contains the final version reached the end of the tutorial.  If
you want to follow along, create backups of @file{money.h},
@file{money.c}, and @file{check_money.c}, and then delete the originals.

We set up a directory structure as follows:
@example
@verbatim
.
|-- Makefile.am
|-- README
|-- configure.ac
|-- src
|   |-- Makefile.am
|   |-- main.c
|   |-- money.c
|   `-- money.h
`-- tests
    |-- Makefile.am
    `-- check_money.c
@end verbatim
@end example

Note that this is the output of @command{tree}, a great directory
visualization tool.  The top-level @file{Makefile.am} is simple; it
merely tells Automake how to process subdirectories:
@example
@verbatim
SUBDIRS = src . tests
@end verbatim
@end example

Note that @code{tests} comes last, because the code should be testing
an already compiled library.  @file{configure.ac} is standard Autoconf
boilerplate, as specified by the Autotools tutorial and as suggested
by @command{autoscan}.  The @code{AM_PATH_CHECK()} is the only line
particular to Check @pxref{AM_PATH_CHECK}.

@file{src/Makefile.am} builds @samp{libmoney} as a Libtool archive,
and links it to an application simply called @command{main}.  The
application's behaviour is not important to this tutorial; what's
important is that none of the functions we want to unit test appear in
@file{main.c}; this probably means that the only function in
@file{main.c} should be @code{main()} itself.  In order to test the
whole application, unit testing is not appropriate: you should use a
system testing tool like Autotest.  If you really want to test
@code{main()} using Check, rename it to something like
@code{_myproject_main()} and write a wrapper around it.

The primary build instructions for our unit tests are in
@file{tests/Makefile.am}:

@example
@verbatiminclude example/tests/Makefile.am
@end example

@code{TESTS} tells Automake which test programs to run for
@command{make check}.  Similarly, the @code{check_} prefix in
@code{check_PROGRAMS} actually comes from Automake; it says to build
these programs only when @command{make check} is run.  (Recall that
Automake's @code{check} target is the origin of Check's name.)  The
@command{check_money} test is a program that we will build from
@file{tests/check_money.c}, linking it against both
@file{src/libmoney.la} and the installed @file{libcheck.la} on our
system.  The appropriate compiler and linker flags for using Check are
found in @code{@@CHECK_CFLAGS@@} and @code{@@CHECK_LIBS@@}, values
defined by the @code{AM_PATH_CHECK} macro.

Now that all this infrastructure is out of the way, we can get on with
development.  @file{src/money.h} should only contain standard C header
boilerplate:

@example
@verbatiminclude example/src/money.1.h
@end example

@file{src/money.c} should be empty, and @file{tests/check_money.c}
should only contain an empty @code{main()} function:

@example
@verbatiminclude example/tests/check_money.1.c
@end example

Create the GNU Build System for the project and then build @file{main}
and @file{libmoney.la} as follows:
@example
@verbatim
$ autoreconf --install
$ ./configure
$ make
@end verbatim
@end example

(@command{autoreconf} determines which commands are needed in order
for @command{configure} to be created or brought up to date.
Previously one would use a script called @command{autogen.sh} or
@command{bootstrap}, but that practice is unnecessary now.)

Now build and run the @command{check_money} test with @command{make
check}.  If all goes well, @command{make} should report that our tests
passed.  No surprise, because there aren't any tests to fail.  If you
have problems, make sure to see @ref{AM_PATH_CHECK}.

This was tested on the i386 ``testing'' distribution of Debian
GNU/Linux (etch) in March 2006, using Autoconf 2.59, Automake 1.9.6,
and Libtool 1.5.22.  Please report any problems to
@email{check-devel@@lists.sourceforge.net}.

@node Test a Little, Creating a Suite, Setting Up the Money Build, Tutorial
@section Test a Little, Code a Little

The @uref{http://junit.sourceforge.net/doc/testinfected/testing.htm,
Test Infected} article starts out with a @code{Money} class, and so
will we.  Of course, we can't do classes with C, but we don't really
need to.  The Test Infected approach to writing code says that we
should write the unit test @emph{before} we write the code, and in
this case, we will be even more dogmatic and doctrinaire than the
authors of Test Infected (who clearly don't really get this stuff,
only being some of the originators of the Patterns approach to
software development and OO design).

Here are the changes to @file{check_money.c} for our first unit test:

@example
@verbatiminclude example/tests/check_money.1-2.c.diff
@end example

@findex fail_unless()
A unit test should just chug along and complete.  If it exits early,
or is signaled, it will fail with a generic error message.  (Note: it
is conceivable that you expect an early exit, or a signal.  There is
currently nothing in Check to specifically assert that we should
expect either --- if that is valuable, it may be worth while adding to
Check.)  If we want to get some information about what failed, we need
to use the @code{fail_unless()} function.  The function (actually a
macro) takes a first Boolean argument, and an error message to send if
the condition is not true.

@findex fail()
If the Boolean argument is too complicated to elegantly express within
@code{fail_unless()}, there is an alternate function @code{fail()}
that unconditionally fails.  The second test inside
@code{test_money_create} above could be rewritten as follows:
@example
@verbatim
   if (strcmp (money_currency (m), "USD") != 0) 
     {
       fail ("Currency not set correctly on creation");
     }
@end verbatim
@end example

@findex fail_if()
There is also a @code{fail_if()} function, which is the
inverse of @code{fail_unless()}.  Using it, the above test then
looks like this:
@example
@verbatim
   fail_if (strcmp (money_currency (m), "USD") != 0,
            "Currency not set correctly on creation");
@end verbatim
@end example

For your convenience all fail functions also accepts NULL as the msg
argument and substitutes a suitable message for you.  So you could also
write a test as follows:
@example
@verbatim
   fail_unless (money_amount (m) == 5, NULL);
@end verbatim
@end example

This is equivalent to:
@example
@verbatim
   fail_unless (money_amount (m) == 5, 
                "Assertion 'money_amount (m) == 5' failed");
@end verbatim
@end example

All fail functions also support @code{varargs} and accept
@code{printf}-style format strings and arguments.  This is especially
useful while debugging.  With @code{printf}-style formatting the
message could look like this:
@example
@verbatim
fail_unless(money_amount (m) == 5,
            "Amount was %d, instead of 5", money_amount (m));
@end verbatim
@end example

When we try to compile and run the test suite now using @command{make
check}, we get a whole host of compilation errors.  It may seem a bit
strange to deliberately write code that won't compile, but notice what
we are doing: in creating the unit test, we are also defining
requirements for the money interface.  Compilation errors are, in a
way, unit test failures of their own, telling us that the
implementation does not match the specification.  If all we do is edit
the sources so that the unit test compiles, we are actually making
progress, guided by the unit tests, so that's what we will now do.

We will patch our header @file{money.h} as follows:

@example
@verbatiminclude example/src/money.1-2.h.diff
@end example

Our code compiles now, and again passes all of the tests.  However,
once we try to @emph{use} the functions in @code{libmoney} in the
@code{main()} of @code{check_money}, we'll run into more problems, as
they haven't actually been implemented yet.

@node Creating a Suite,  , Test a Little, Tutorial
@section Creating a Suite

To run unit tests with Check, we must create some test cases,
aggregate them into a suite, and run them with a suite runner. That's
a bit of overhead, but it is mostly one-off.  Here's a diff for the
new version of @file{check_money.c}.  Note that we include stdlib.h to
get the definitions of @code{EXIT_SUCCESS} and @code{EXIT_FAILURE}.

@example
@verbatiminclude example/tests/check_money.2-3.c.diff
@end example

Most of the @code{money_suite()} code should be self-explanatory.  We are
creating a suite, creating a test case, adding the test case to the
suite, and adding the unit test we created above to the test case.
Why separate this off into a separate function, rather than inline it
in @code{main()}?  Because any new tests will get added in
@code{money_suite()}, but nothing will need to change in @code{main()}
for the rest of this example, so main will stay relatively clean and
simple.

Unit tests are internally defined as static functions.  This means
that the code to add unit tests to test cases must be in the same
compilation unit as the unit tests themselves.  This provides another
reason to put the creation of the test suite in a separate function:
you may later want to keep one source file per suite; defining a
uniquely named suite creation function allows you later to define a
header file giving prototypes for all the suite creation functions,
and encapsulate the details of where and how unit tests are defined
behind those functions.  See the test program defined for Check itself
for an example of this strategy.

The code in @code{main()} bears some explanation.  We are creating a
suite runner object of type @code{SRunner} from the @code{Suite} we
created in @code{money_suite()}.  We then run the suite, using the
@code{CK_NORMAL} flag to specify that we should print a summary of the
run, and list any failures that may have occurred.  We capture the
number of failures that occurred during the run, and use that to
decide how to return.  The @code{check} target created by Automake
uses the return value to decide whether the tests passed or failed.

Now that the tests are actually being run by @command{check_money}, we
encounter linker errors again we try out @code{make check}.  Try it
for yourself and see.  The reason is that the @file{money.c}
implementation of the @file{money.h} interface hasn't been created
yet.  Let's go with the fastest solution possible and implement stubs
for each of the functions in @code{money.c}:

@example
@verbatiminclude example/src/money.1-3.c.diff
@end example

Note that we @code{#include <stdlib.h>} to get the definition of
@code{NULL}.  Now, the code compiles and links when we run @code{make
check}, but our unit test fails.  Still, this is progress, and we can
focus on making the test pass.

@node AM_PATH_CHECK, Copying This Manual, Tutorial, Top
@chapter AM_PATH_CHECK
@findex AM_PATH_CHECK

The @code{AM_PATH_CHECK()} macro is defined in the file
@file{check.m4} which is installed by Check.  It has some optional
parameters that you might find useful in your @file{configure.ac}:
@verbatim
AM_PATH_CHECK([MINIMUM-VERSION,
               [ACTION-IF-FOUND[,ACTION-IF-NOT-FOUND]]])
@end verbatim

@code{AM_PATH_CHECK} does several things:

@enumerate
@item 
It ensures check.h is available

@item 
It ensures a compatible version of Check is installed

@item 
It sets @env{CHECK_CFLAGS} and @env{CHECK_LIBS} for use by Automake.
@end enumerate

If you include @code{AM_PATH_CHECK()} in @file{configure.ac} and
subsequently see warnings when attempting to create
@command{configure}, it probably means one of the following things:

@enumerate
@item 
You forgot to call @command{aclocal}.  @command{autoreconf} will do
this for you.

@item
@command{aclocal} can't find  @file{check.m4}.  Here are some possible
solutions:

@enumerate a
@item
Call @command{aclocal} with @option{-I} set to the location of
@file{check.m4}.  This means you have to call both @command{aclocal} and
@command{autoreconf}.

@item
Add the location of @file{check.m4} to the @samp{dirlist} used by
@command{aclocal} and then call @command{autoreconf}.  This means you
need permission to modify the @samp{dirlist}.

@item
Set @code{ACLOCAL_AMFLAGS} in your top-level @file{Makefile.am} to
include @option{-I DIR} with @code{DIR} being the location of
@file{check.m4}.  Then call @command{autoreconf}.
@end enumerate
@end enumerate

@node Copying This Manual, Index, AM_PATH_CHECK, Top
@appendix Copying This Manual

@menu
* GNU Free Documentation License::  License for copying this manual.
@end menu

@include fdl.texi


@node Index,  , Copying This Manual, Top
@unnumbered Index

@printindex cp

@bye
